# SunAllocator SSR controller — ESP-01(S), 2 channels (DC SSR by default)
# IMPORTANT BOOT NOTES FOR ESP-01:
# - Usable GPIOs: GPIO0 and GPIO2 only. Both are bootstrapping pins and must be HIGH at boot.
# - Do NOT connect SSR inputs that pull these pins low during boot, or the ESP will fail to boot.
# - Recommended: Use a transistor/driver stage with proper pull-ups to 3.3V on both pins.
# - If in doubt, start with single-channel (GPIO2 only) configuration.
#
# Default here uses fast PWM (DC SSR / MOSFET). For AC SSR, you can switch to slow_pwm
# (comment esp8266_pwm outputs and uncomment the slow_pwm alternatives below).

esphome:
  name: sunallocator-relay-esp01-2ch
  comment: "SunAllocator SSR controller (ESP-01, 2 channels)"

esp8266:
  board: esp01_1m

logger:
  baud_rate: 0
api:
  on_client_disconnected:
    then:
      - logger.log: "API disconnected → turning relays OFF (fail-safe)"
      - light.turn_off: sv_relay_light_1
      - light.turn_off: sv_relay_light_2
      - select.set_option:
          id: sv_mode_select_1
          option: "Off"
      - select.set_option:
          id: sv_mode_select_2
          option: "Off"
ota:
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "SV-SSR-Setup"

# OUTPUTS (DC SSR default — fast PWM)
output:
  - platform: esp8266_pwm
    id: sv_ssr_out_1
    pin: GPIO2          # Boot pin: keep pulled up, avoid heavy load at boot
    frequency: 1000 Hz
  - platform: esp8266_pwm
    id: sv_ssr_out_2
    pin: GPIO0          # Boot pin: keep pulled up, avoid heavy load at boot
    frequency: 1000 Hz
  # On-board status LED (ESP-01 blue LED on GPIO1/TX, active-low)
  - platform: gpio
    id: sv_status_led_out
    pin: GPIO1
    inverted: true

# Alternative for AC SSR — use slow_pwm
# output:
#   - platform: slow_pwm
#     id: sv_ssr_out_1
#     pin: GPIO2
#     period: 1.5s
#   - platform: slow_pwm
#     id: sv_ssr_out_2
#     pin: GPIO0
#     period: 1.5s

light:
  - platform: monochromatic
    name: "SunAllocator Relay 1"
    id: sv_relay_light_1
    output: sv_ssr_out_1
    restore_mode: ALWAYS_OFF
  - platform: monochromatic
    name: "SunAllocator Relay 2"
    id: sv_relay_light_2
    output: sv_ssr_out_2
    restore_mode: ALWAYS_OFF

select:
  - platform: template
    name: "SunAllocator Mode 1"
    id: sv_mode_select_1
    optimistic: true
    options: ["Off", "On", "Proportional"]
    initial_option: "Off"
    set_action:
      then:
        - lambda: |-
            auto opt = id(sv_mode_select_1).state.c_str();
            if (strcmp(opt, "Off") == 0) {
              id(sv_relay_light_1).turn_off();
            } else if (strcmp(opt, "On") == 0) {
              auto call = id(sv_relay_light_1).turn_on();
              call.set_brightness(1.0f);
              call.perform();
            } else if (strcmp(opt, "Proportional") == 0) {
              auto call = id(sv_relay_light_1).turn_on();
              call.perform();
            }
  - platform: template
    name: "SunAllocator Mode 2"
    id: sv_mode_select_2
    optimistic: true
    options: ["Off", "On", "Proportional"]
    initial_option: "Off"
    set_action:
      then:
        - lambda: |-
            auto opt = id(sv_mode_select_2).state.c_str();
            if (strcmp(opt, "Off") == 0) {
              id(sv_relay_light_2).turn_off();
            } else if (strcmp(opt, "On") == 0) {
              auto call = id(sv_relay_light_2).turn_on();
              call.set_brightness(1.0f);
              call.perform();
            } else if (strcmp(opt, "Proportional") == 0) {
              auto call = id(sv_relay_light_2).turn_on();
              call.perform();
            }

script:
  - id: sv_led_pulse
    then:
      - output.turn_on: sv_status_led_out
      - delay: 200ms
      - output.turn_off: sv_status_led_out

interval:
  # Fast blink every 2s when any channel is in Proportional mode and power > 0%
  - interval: 2s
    then:
      - if:
          condition:
            lambda: |
              bool p1 = (id(sv_mode_select_1).state == "Proportional") && (id(sv_relay_light_1).current_values.get_brightness() > 0.0f);
              bool p2 = (id(sv_mode_select_2).state == "Proportional") && (id(sv_relay_light_2).current_values.get_brightness() > 0.0f);
              return p1 || p2;
          then:
            - script.execute: sv_led_pulse

  # Solid ON when any channel enabled (On/Proportional) but none currently outputting proportional power
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |
              bool p1 = (id(sv_mode_select_1).state == "Proportional") && (id(sv_relay_light_1).current_values.get_brightness() > 0.0f);
              bool p2 = (id(sv_mode_select_2).state == "Proportional") && (id(sv_relay_light_2).current_values.get_brightness() > 0.0f);
              bool prop_active = p1 || p2;
              auto s1 = id(sv_mode_select_1).state;
              auto s2 = id(sv_mode_select_2).state;
              bool enabled = (s1 == "On" || s1 == "Proportional" || s2 == "On" || s2 == "Proportional");
              return enabled && !prop_active;
          then:
            - output.turn_on: sv_status_led_out
          else:
            - output.turn_off: sv_status_led_out

  # Heartbeat: blink every 10 minutes when both channels Off
  - interval: 10min
    then:
      - if:
          condition:
            lambda: 'return id(sv_mode_select_1).state == "Off" && id(sv_mode_select_2).state == "Off";'
          then:
            - script.execute: sv_led_pulse

sensor:
  - platform: wifi_signal
    name: "SV ESP01 WiFi Signal"
    update_interval: 30s
  - platform: uptime
    name: "SV ESP01 Uptime"

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "SV ESP01 IP"